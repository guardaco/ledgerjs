{"version":3,"sources":["../src/index.js"],"names":["createLedgerSubprovider","allowedHdPaths","makeError","msg","id","err","Error","obtainPathComponentsFromDerivationPath","derivationPath","regExp","matchResult","exec","basePath","index","parseInt","defaultOptions","networkId","path","askConfirm","accountsLength","accountsOffset","getTransport","options","transport","eth","addresses","i","pathComponents","toString","getAddress","address","addressToPathMap","toLowerCase","close","getAccounts","msgData","from","signPersonalMessage","data","result","v","vHex","length","r","s","txData","tx","raw","Buffer","signTransaction","serialize","signedChainId","Math","floor","validChainId","some","startsWith","hdPref","join","subprovider","then","callback","Object","values","res","catch"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\nimport AppEth from \"@ledgerhq/hw-app-eth\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport HookedWalletSubprovider from \"web3-provider-engine/dist/es5/subproviders/hooked-wallet\";\nimport stripHexPrefix from \"strip-hex-prefix\";\nimport EthereumTx from \"ethereumjs-tx\";\n\nconst allowedHdPaths = [\"44'/1'\", \"44'/60'\", \"44'/61'\"];\n\nfunction makeError(msg, id) {\n  const err = new Error(msg);\n  // $FlowFixMe\n  err.id = id;\n  return err;\n}\n\nfunction obtainPathComponentsFromDerivationPath(derivationPath) {\n  // check if derivation path follows 44'/60'/x'/n pattern\n  const regExp = /^(44'\\/(?:1|60|61)'\\/\\d+'?\\/)(\\d+)$/;\n  const matchResult = regExp.exec(derivationPath);\n  if (matchResult === null) {\n    throw makeError(\n      \"To get multiple accounts your derivation path must follow pattern 44'/60|61'/x'/n \",\n      \"InvalidDerivationPath\"\n    );\n  }\n  return { basePath: matchResult[1], index: parseInt(matchResult[2], 10) };\n}\n\n/**\n */\ntype SubproviderOptions = {\n  // refer to https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\n  networkId: number,\n  // derivation path\n  path?: string,\n  // should use actively validate on the device\n  askConfirm?: boolean,\n  // number of accounts to derivate\n  accountsLength?: number,\n  // offset index to use to start derivating the accounts\n  accountsOffset?: number\n};\n\nconst defaultOptions = {\n  networkId: 1, // mainnet\n  path: \"44'/60'/0'/0\", // ledger default derivation path\n  askConfirm: false,\n  accountsLength: 1,\n  accountsOffset: 0\n};\n\n/**\n * Create a HookedWalletSubprovider for Ledger devices.\n * @param getTransport gets lazily called each time the device is needed. It is a function that returns a Transport instance. You can typically give `()=>TransportU2F.create()`\n * @example\nimport Web3 from \"web3\";\nimport createLedgerSubprovider from \"@ledgerhq/web3-subprovider\";\nimport TransportU2F from \"@ledgerhq/hw-transport-u2f\";\nimport ProviderEngine from \"web3-provider-engine\";\nimport RpcSubprovider from \"web3-provider-engine/subproviders/rpc\";\nconst engine = new ProviderEngine();\nconst getTransport = () => TransportU2F.create();\nconst ledger = createLedgerSubprovider(getTransport, {\n  accountsLength: 5\n});\nengine.addProvider(ledger);\nengine.addProvider(new RpcSubprovider({ rpcUrl }));\nengine.start();\nconst web3 = new Web3(engine);\n */\nexport default function createLedgerSubprovider(\n  getTransport: () => Transport<*>,\n  options?: SubproviderOptions\n): HookedWalletSubprovider {\n  const { networkId, path, askConfirm, accountsLength, accountsOffset } = {\n    ...defaultOptions,\n    ...options\n  };\n  if (!allowedHdPaths.some(hdPref => path.startsWith(hdPref))) {\n    throw makeError(\n      \"Ledger derivation path allowed are \" +\n        allowedHdPaths.join(\", \") +\n        \". \" +\n        path +\n        \" is not supported\",\n      \"InvalidDerivationPath\"\n    );\n  }\n\n  const pathComponents = obtainPathComponentsFromDerivationPath(path);\n\n  const addressToPathMap = {};\n\n  async function getAccounts() {\n    const transport = await getTransport();\n    try {\n      const eth = new AppEth(transport);\n      const addresses = {};\n      for (let i = accountsOffset; i < accountsOffset + accountsLength; i++) {\n        const path =\n          pathComponents.basePath + (pathComponents.index + i).toString();\n        const address = await eth.getAddress(path, askConfirm, false);\n        addresses[path] = address.address;\n        addressToPathMap[address.address.toLowerCase()] = path;\n      }\n      return addresses;\n    } finally {\n      transport.close();\n    }\n  }\n\n  async function signPersonalMessage(msgData) {\n    const path = addressToPathMap[msgData.from.toLowerCase()];\n    if (!path) throw new Error(\"address unknown '\" + msgData.from + \"'\");\n    const transport = await getTransport();\n    try {\n      const eth = new AppEth(transport);\n      const result = await eth.signPersonalMessage(\n        path,\n        stripHexPrefix(msgData.data)\n      );\n      const v = parseInt(result.v, 10) - 27;\n      let vHex = v.toString(16);\n      if (vHex.length < 2) {\n        vHex = `0${v}`;\n      }\n      return `0x${result.r}${result.s}${vHex}`;\n    } finally {\n      transport.close();\n    }\n  }\n\n  async function signTransaction(txData) {\n    const path = addressToPathMap[txData.from.toLowerCase()];\n    if (!path) throw new Error(\"address unknown '\" + txData.from + \"'\");\n    const transport = await getTransport();\n    try {\n      const eth = new AppEth(transport);\n      const tx = new EthereumTx(txData);\n\n      // Set the EIP155 bits\n      tx.raw[6] = Buffer.from([networkId]); // v\n      tx.raw[7] = Buffer.from([]); // r\n      tx.raw[8] = Buffer.from([]); // s\n\n      // Pass hex-rlp to ledger for signing\n      const result = await eth.signTransaction(\n        path,\n        tx.serialize().toString(\"hex\")\n      );\n\n      // Store signature in transaction\n      tx.v = Buffer.from(result.v, \"hex\");\n      tx.r = Buffer.from(result.r, \"hex\");\n      tx.s = Buffer.from(result.s, \"hex\");\n\n      // EIP155: v should be chain_id * 2 + {35, 36}\n      const signedChainId = Math.floor((tx.v[0] - 35) / 2);\n      const validChainId = networkId & 0xff; // FIXME this is to fixed a current workaround that app don't support > 0xff\n      if (signedChainId !== validChainId) {\n        throw makeError(\n          \"Invalid networkId signature returned. Expected: \" +\n            networkId +\n            \", Got: \" +\n            signedChainId,\n          \"InvalidNetworkId\"\n        );\n      }\n\n      return `0x${tx.serialize().toString(\"hex\")}`;\n    } finally {\n      transport.close();\n    }\n  }\n\n  const subprovider = new HookedWalletSubprovider({\n    getAccounts: callback => {\n      getAccounts()\n        .then(res => callback(null, Object.values(res)))\n        .catch(err => callback(err, null));\n    },\n    signPersonalMessage: (txData, callback) => {\n      signPersonalMessage(txData)\n        .then(res => callback(null, res))\n        .catch(err => callback(err, null));\n    },\n    signTransaction: (txData, callback) => {\n      signTransaction(txData)\n        .then(res => callback(null, res))\n        .catch(err => callback(err, null));\n    }\n  });\n\n  return subprovider;\n}\n"]}