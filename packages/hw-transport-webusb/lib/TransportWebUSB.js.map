{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","interfaceNumber","endpointNumber","TransportWebUSB","device","releaseInterface","reset","close","open","configuration","selectConfiguration","claimInterface","isSupported","list","listen","observer","unsubscribed","then","next","type","descriptor","complete","unsubscribe","channel","Math","floor","random","packetSize","exchange","apdu","atomic","debug","toString","framing","blocks","makeBlocks","i","length","transferOut","result","acc","getReducedResult","transferIn","r","reduceResponse","Buffer","from","data","buffer","f","busy","resolveBusy","busyPromise","res"],"mappings":"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","file":"TransportWebUSB.js","sourcesContent":["//@flow\nimport Transport, { TransportError } from \"../../hw-transport/lib/Transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"../../hw-transport/lib/Transport\";\nimport { getLedgerDevices, requestLedgerDevice, isSupported } from \"./webusb\";\nimport hidFraming from \"./hid-framing\";\n\nconst configurationValue = 1;\nconst interfaceNumber = 2;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: USBDevice) {\n    super();\n    this.device = device;\n  }\n\n  static isSupported = isSupported;\n\n  static list = getLedgerDevices;\n\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    requestLedgerDevice().then(device => {\n      if (!unsubscribed) {\n        observer.next({ type: \"add\", descriptor: device, device });\n        observer.complete();\n      }\n    });\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await device.reset();\n    await device.claimInterface(interfaceNumber);\n    return new TransportWebUSB(device);\n  }\n\n  async close(): Promise<void> {\n    await this.device.releaseInterface(interfaceNumber);\n    await this.device.reset();\n    await this.device.close();\n  }\n\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.atomic(async () => {\n      const { debug, channel, packetSize } = this;\n      if (debug) {\n        debug(\"=>\" + apdu.toString(\"hex\"));\n      }\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        acc = framing.reduceResponse(acc, Buffer.from(r.data.buffer));\n      }\n\n      if (debug) {\n        debug(\"<=\" + result.toString(\"hex\"));\n      }\n      return result;\n    });\n\n  setScrambleKey() {}\n\n  busy: ?Promise<void>;\n\n  // $FlowFixMe\n  atomic = async f => {\n    if (this.busy) {\n      throw new TransportError(\"Transport race condition\", \"RaceCondition\");\n    }\n    let resolveBusy;\n    const busyPromise = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.busy = busyPromise;\n    try {\n      const res = await f();\n      return res;\n    } finally {\n      if (resolveBusy) resolveBusy();\n      this.busy = null;\n    }\n  };\n}\n"]}