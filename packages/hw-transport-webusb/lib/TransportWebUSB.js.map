{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","endpointNumber","TransportWebUSB","device","interfaceNumber","deviceModel","productId","exchangeBusyPromise","releaseInterface","reset","close","open","devices","length","configuration","selectConfiguration","iface","configurations","interfaces","find","alternates","some","a","interfaceClass","TransportInterfaceNotAvailable","claimInterface","message","transport","onDisconnect","e","navigator","usb","removeEventListener","_emitDisconnect","DisconnectedDevice","addEventListener","Transport","isSupported","list","getLedgerDevices","listen","observer","unsubscribed","then","next","type","descriptor","complete","window","DOMException","error","code","TransportWebUSBGestureRequired","TransportOpenUserCancelled","unsubscribe","channel","Math","floor","random","packetSize","_disconnectEmitted","emit","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","transferOut","result","acc","getReducedResult","transferIn","r","buffer","Buffer","from","data","reduceResponse","catch","includes","DisconnectedDeviceDuringOperation"],"mappings":"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","file":"TransportWebUSB.js","sourcesContent":["//@flow\nimport Transport from \"../../hw-transport/lib/Transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"../../hw-transport/lib/Transport\";\nimport hidFraming from \"../../devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"../../devices/lib\";\nimport type { DeviceModel } from \"../../devices/lib\";\nimport { log } from \"../../logs/lib\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice\n} from \"../../errors/lib\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      device => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      error => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await device.reset();\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some(a => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await this.device.reset();\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        log(\"hid-frame\", \"=> \" + blocks[i].toString(\"hex\"));\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        log(\"hid-frame\", \"<= \" + buffer.toString(\"hex\"));\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]}