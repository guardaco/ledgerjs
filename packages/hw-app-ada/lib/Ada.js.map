{"version":3,"sources":["../src/Ada.js"],"names":["CLA","INS_GET_PUBLIC_KEY","INS_SET_TX","INS_SIGN_TX","INS_APP_INFO","P1_FIRST","P1_NEXT","P1_LAST","P2_SINGLE_TX","P2_MULTI_TX","MAX_APDU_SIZE","OFFSET_CDATA","MAX_ADDR_PRINT_LENGTH","INDEX_MAX","INDEX_NAN","INDEX_MAX_EXCEEDED","Ada","transport","scrambleKey","methods","decorateAppAPIMethods","send","response","major","minor","patch","publicKeyLength","publicKey","slice","toString","chainCode","index","isNaN","data","Buffer","alloc","writeUInt32BE","txHex","indexes","setTransaction","signTransactionWithIndexes","rawTx","from","chunkSize","i","length","chunk","p2","p1","res","inputs","outputs","txs","offset","address","amount","readUInt32LE","toOctetString","push","digest"],"mappings":"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","file":"Ada.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// @flow\n\nimport Int64 from \"node-int64\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { TransportStatusError } from \"@ledgerhq/hw-transport\";\n\nconst CLA = 0x80;\n\nconst INS_GET_PUBLIC_KEY = 0x01;\nconst INS_SET_TX = 0x02;\nconst INS_SIGN_TX = 0x03;\nconst INS_APP_INFO = 0x04;\n\nconst P1_FIRST = 0x01;\nconst P1_NEXT = 0x02;\nconst P1_LAST = 0x03;\n\nconst P2_SINGLE_TX = 0x01;\nconst P2_MULTI_TX = 0x02;\n\nconst MAX_APDU_SIZE = 64;\nconst OFFSET_CDATA = 5;\nconst MAX_ADDR_PRINT_LENGTH = 12;\nconst INDEX_MAX = 0xffffffff;\n\nconst INDEX_NAN = 0x5003;\nconst INDEX_MAX_EXCEEDED = 0x5302;\n\n/**\n * Cardano ADA API\n *\n * @example\n * import Ada from \"@ledgerhq/hw-app-ada\";\n * const ada = new Ada(transport);\n */\nexport default class Ada {\n  transport: Transport<*>;\n  methods: Array<string>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"ADA\") {\n    this.transport = transport;\n    this.methods = [\n      \"isConnected\",\n      \"getWalletRecoveryPassphrase\",\n      \"getWalletPublicKeyWithIndex\",\n      \"signTransaction\"\n    ];\n    this.transport.decorateAppAPIMethods(this, this.methods, scrambleKey);\n  }\n\n  /**\n   * Checks if the device is connected and if so, returns an object\n   * containing the app version.\n   *\n   * @returns {Promise<{major:number, minor:number, patch:number}>} Result object containing the application version number.\n   *\n   * @example\n   * const { major, minor, patch } = await ada.isConnected();\n   * console.log(`App version ${major}.${minor}.${patch}`);\n   *\n   */\n  async isConnected(): Promise<{\n    major: string,\n    minor: string,\n    patch: string\n  }> {\n    const response = await this.transport.send(CLA, INS_APP_INFO, 0x00, 0x00);\n\n    const [major, minor, patch] = response;\n    return { major, minor, patch };\n  }\n\n  /**\n   * @description Get the root extended public key of the wallet,\n   * also known as the wallet recovery passphrase.\n   * BIP 32 Path M 44' /1815'\n   * 32 Byte Public Key\n   * 32 Byte Chain Code\n   *\n   * @return {Promise<{ publicKey:string, chainCode:string }>} The result object containing the root wallet public key and chaincode.\n   *\n   * @example\n   * const { publicKey, chainCode } = await ada.getWalletRecoveryPassphrase();\n   * console.log(publicKey);\n   * console.log(chainCode);\n   *\n   */\n  async getWalletRecoveryPassphrase(): Promise<{\n    publicKey: string,\n    chainCode: string\n  }> {\n    const response = await this.transport.send(\n      CLA,\n      INS_GET_PUBLIC_KEY,\n      0x01,\n      0x00\n    );\n\n    const [publicKeyLength] = response;\n    const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n    const chainCode = response\n      .slice(1 + publicKeyLength, 1 + publicKeyLength + 32)\n      .toString(\"hex\");\n\n    return { publicKey, chainCode };\n  }\n\n  /**\n   * @description Get a public key from the specified BIP 32 index.\n   * The BIP 32 index is from the path at `44'/1815'/0'/[index]`.\n   *\n   * @param {number} index The index to retrieve.\n   * @return {Promise<{ publicKey:string }>} The public key for the given index.\n   *\n   * @throws 5201 - Non-hardened index passed in, Index < 0x80000000\n   * @throws 5202 - Invalid header\n   * @throws 5003 - Index not a number\n   *\n   * @example\n   * const { publicKey } = await ada.getWalletPublicKeyWithIndex(0xC001CODE);\n   * console.log(publicKey);\n   *\n   */\n  async getWalletPublicKeyWithIndex(\n    index: number\n  ): Promise<{ publicKey: string }> {\n    if (isNaN(index)) {\n      throw new TransportStatusError(INDEX_NAN);\n    }\n\n    const data = Buffer.alloc(4);\n    data.writeUInt32BE(index, 0);\n\n    const response = await this.transport.send(\n      CLA,\n      INS_GET_PUBLIC_KEY,\n      0x02,\n      0x00,\n      data\n    );\n\n    const [publicKeyLength] = response;\n    const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n\n    return { publicKey };\n  }\n\n  /**\n   * @description Signs a hex encoded transaction with the given indexes.\n   * The transaction is hased using Blake2b on the Ledger device.\n   * Then, signed by the private key derived from each of the passed in indexes at\n   * path 44'/1815'/0'/[index].\n   *\n   * @param {string} txHex The transaction to be signed.\n   * @param {number[]} indexes The indexes of the keys to be used for signing.\n   * @return {Array.Promise<{ digest:string }>} An array of result objects containing a digest for each of the passed in indexes.\n   *\n   * @throws 5001 - Tx > 1024 bytes\n   * @throws 5301 - Index < 0x80000000\n   * @throws 5302 - Index > 0xFFFFFFFF\n   * @throws 5003 - Index not a number\n   *\n   * @example\n   * const transaction = '839F8200D8185826825820E981442C2BE40475BB42193CA35907861D90715854DE6FCBA767B98F1789B51219439AFF9F8282D818584A83581CE7FE8E468D2249F18CD7BF9AEC0D4374B7D3E18609EDE8589F82F7F0A20058208200581C240596B9B63FC010C06FBE92CF6F820587406534795958C411E662DC014443C0688E001A6768CC861B0037699E3EA6D064FFA0';\n   * const { digest } = await ada.signTransaction(transaction, [0xF005BA11]);\n   * console.log(`Signed successfully: ${digest}`);\n   *\n   */\n  async signTransaction(\n    txHex: string,\n    indexes: Array<number>\n  ): Promise<Array<{ digest: string }>> {\n    await this.setTransaction(txHex);\n    return this.signTransactionWithIndexes(indexes);\n  }\n\n  /**\n   * Set the transaction.\n   *\n   * @param {string} txHex The transaction to be set.\n   * @return Promise<{ inputs?: string, outputs?: string, txs?: Array<{ address: string, amount: string }> }>  The response from the device.\n   * @private\n   */\n  async setTransaction(\n    txHex: string\n  ): Promise<{\n    inputs?: string,\n    outputs?: string,\n    txs?: Array<{ address: string, amount: string }>\n  }> {\n    const rawTx = Buffer.from(txHex, \"hex\");\n    const chunkSize = MAX_APDU_SIZE - OFFSET_CDATA;\n    let response = {};\n\n    for (let i = 0; i < rawTx.length; i += chunkSize) {\n      const chunk = rawTx.slice(i, i + chunkSize);\n      const p2 = rawTx.length < chunkSize ? P2_SINGLE_TX : P2_MULTI_TX;\n      let p1 = P1_NEXT;\n\n      if (i === 0) {\n        p1 = P1_FIRST;\n      } else if (i + chunkSize >= rawTx.length) {\n        p1 = P1_LAST;\n      }\n\n      const res = await this.transport.send(CLA, INS_SET_TX, p1, p2, chunk);\n\n      if (res.length > 4) {\n        const [inputs, outputs] = res;\n        const txs = [];\n\n        let offset = 2;\n        for (let i = 0; i < outputs; i++) {\n          let address = res\n            .slice(offset, offset + MAX_ADDR_PRINT_LENGTH)\n            .toString();\n          offset += MAX_ADDR_PRINT_LENGTH;\n          let amount = new Int64(\n            res.readUInt32LE(offset + 4),\n            res.readUInt32LE(offset)\n          ).toOctetString();\n          txs.push({ address, amount });\n          offset += 8;\n        }\n\n        response = { inputs, outputs, txs };\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Sign the set transaction with the given indexes.\n   * Note that setTransaction must be called prior to this being called.\n   *\n   * @param {number[]} indexes The indexes of the keys to be used for signing.\n   * @returns {Array.Promise<Object>} An array of result objects containing a digest for each of the passed in indexes.\n   * @private\n   */\n  async signTransactionWithIndexes(\n    indexes: Array<number>\n  ): Promise<Array<{ digest: string }>> {\n    let response = [];\n\n    for (let i = 0; i < indexes.length; i++) {\n      if (isNaN(indexes[i])) {\n        throw new TransportStatusError(INDEX_NAN);\n      }\n\n      if (indexes[i] > INDEX_MAX) {\n        throw new TransportStatusError(INDEX_MAX_EXCEEDED);\n      }\n\n      const data = Buffer.alloc(4);\n      data.writeUInt32BE(indexes[i], 0);\n\n      const res = await this.transport.send(CLA, INS_SIGN_TX, 0x00, 0x00, data);\n      const digest = res.slice(0, res.length - 2).toString(\"hex\");\n\n      response.push({ digest });\n    }\n\n    return response;\n  }\n}\n"]}