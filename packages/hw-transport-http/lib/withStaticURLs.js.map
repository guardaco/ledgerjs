{"version":3,"sources":["../src/withStaticURLs.js"],"names":["getTransport","url","startsWith","inferURLs","urls","r","StaticTransport","isSupported","list","then","Promise","all","map","check","catch","arrs","reduce","acc","a","concat","listen","observer","unsubscribed","seen","checkLoop","next","type","descriptor","setTimeout","success","unsubscribe","open"],"mappings":"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","file":"withStaticURLs.js","sourcesContent":["// @flow\nimport HttpTransport from \"./HttpTransport\";\nimport WebSocketTransport from \"./WebSocketTransport\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\n\nconst getTransport = url =>\n  !url.startsWith(\"ws\") ? HttpTransport : WebSocketTransport;\n\ntype InS = string | string[];\ntype InP = Promise<InS> | InS;\ntype In = InP | (() => InP);\n\nconst inferURLs = async (urls: In): Promise<string[]> => {\n  const r = await (typeof urls === \"function\" ? urls() : urls);\n  return typeof r === \"string\" ? [r] : r;\n};\n\nexport default (urls: In): Class<Transport<string>> => {\n  class StaticTransport extends Transport<string> {\n    static isSupported = HttpTransport.isSupported;\n\n    static list = (): Promise<*[]> =>\n      inferURLs(urls)\n        .then(urls =>\n          Promise.all(\n            urls.map(url =>\n              getTransport(url)\n                .check(url)\n                .then(() => [url])\n                .catch(() => [])\n            )\n          )\n        )\n        .then(arrs => arrs.reduce((acc, a) => acc.concat(a), []));\n\n    static listen = (observer: Observer<DescriptorEvent<*>>): Subscription => {\n      let unsubscribed = false;\n      const seen = {};\n      function checkLoop() {\n        if (unsubscribed) return;\n        inferURLs(urls)\n          .then(urls =>\n            Promise.all(\n              urls.map(async url => {\n                if (unsubscribed) return;\n                try {\n                  await getTransport(url).check(url);\n                  if (unsubscribed) return;\n                  if (!seen[url]) {\n                    seen[url] = 1;\n                    observer.next({ type: \"add\", descriptor: url });\n                  }\n                } catch (e) {\n                  // nothing\n                  if (seen[url]) {\n                    delete seen[url];\n                    observer.next({ type: \"remove\", descriptor: url });\n                  }\n                }\n              })\n            )\n          )\n          .then(() => new Promise(success => setTimeout(success, 5000)))\n          .then(checkLoop);\n      }\n      checkLoop();\n      return {\n        unsubscribe: () => {\n          unsubscribed = true;\n        }\n      };\n    };\n\n    static open = url => getTransport(url).open(url);\n  }\n\n  return StaticTransport;\n};\n"]}