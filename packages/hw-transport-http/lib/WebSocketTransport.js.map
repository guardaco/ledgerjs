{"version":3,"sources":["../src/WebSocketTransport.js"],"names":["WebSocket","global","require","WebSocketTransport","url","Promise","resolve","reject","socket","exchangeMethods","resolveExchange","_b","rejectExchange","_e","onDisconnect","close","send","msg","onopen","onerror","e","onclose","onmessage","data","JSON","parse","type","Error","error","Buffer","from","hook","emit","apdu","b","toString","setTimeout","success","isSupported","list","listen","_observer","unsubscribe","check","timeout"],"mappings":"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","file":"WebSocketTransport.js","sourcesContent":["//@flow\nimport Transport, { TransportError } from \"@ledgerhq/hw-transport\";\n\nconst WebSocket = global.WebSocket || require(\"ws\");\n\n/**\n * WebSocket transport implementation\n */\nexport default class WebSocketTransport extends Transport<string> {\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof WebSocket === \"function\");\n\n  // this transport is not discoverable\n  static list = (): * => Promise.resolve([]);\n  static listen = (_observer: *) => ({\n    unsubscribe: () => {}\n  });\n\n  static check = async (url: string, timeout: number = 5000) =>\n    new Promise((resolve, reject) => {\n      const socket = new WebSocket(url);\n      let success = false;\n      setTimeout(() => {\n        socket.close();\n      }, timeout);\n      socket.onopen = () => {\n        success = true;\n        socket.close();\n      };\n      socket.onclose = () => {\n        if (success) resolve();\n        else {\n          reject(\n            new TransportError(\n              \"failed to access WebSocketTransport(\" + url + \")\",\n              \"WebSocketTransportNotAccessible\"\n            )\n          );\n        }\n      };\n      socket.onerror = () => {\n        reject(\n          new TransportError(\n            \"failed to access WebSocketTransport(\" + url + \"): error\",\n            \"WebSocketTransportNotAccessible\"\n          )\n        );\n      };\n    });\n\n  static async open(url: string) {\n    const exchangeMethods = await new Promise((resolve, reject) => {\n      try {\n        const socket = new WebSocket(url);\n        const exchangeMethods = {\n          resolveExchange: (_b: Buffer) => {},\n          rejectExchange: (_e: TransportError) => {},\n          onDisconnect: () => {},\n          close: () => socket.close(),\n          send: msg => socket.send(msg)\n        };\n        socket.onopen = () => {\n          socket.send(\"open\");\n        };\n        socket.onerror = e => {\n          exchangeMethods.onDisconnect();\n          reject(e);\n        };\n        socket.onclose = () => {\n          exchangeMethods.onDisconnect();\n          reject(new TransportError(\"OpenFailed\", \"OpenFailed\"));\n        };\n        socket.onmessage = e => {\n          if (typeof e.data !== \"string\") return;\n          const data = JSON.parse(e.data);\n          switch (data.type) {\n            case \"opened\":\n              return resolve(exchangeMethods);\n            case \"error\":\n              reject(new Error(data.error));\n              return exchangeMethods.rejectExchange(\n                new TransportError(data.error, \"WSError\")\n              );\n            case \"response\":\n              return exchangeMethods.resolveExchange(\n                Buffer.from(data.data, \"hex\")\n              );\n          }\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n    return new WebSocketTransport(exchangeMethods);\n  }\n\n  hook: *;\n\n  constructor(hook: *) {\n    super();\n    this.hook = hook;\n    hook.onDisconnect = () => {\n      this.emit(\"disconnect\");\n      this.hook.rejectExchange(\n        new TransportError(\"WebSocket disconnected\", \"WSDisconnect\")\n      );\n    };\n  }\n\n  exchange(apdu: Buffer): Promise<Buffer> {\n    return new Promise((resolve, reject) => {\n      this.hook.rejectExchange = (e: TransportError) => reject(e);\n      this.hook.resolveExchange = (b: Buffer) => resolve(b);\n      this.hook.send(apdu.toString(\"hex\"));\n    });\n  }\n\n  setScrambleKey() {}\n\n  async close() {\n    this.hook.close();\n    return new Promise(success => {\n      setTimeout(success, 200);\n    });\n  }\n}\n"]}