{"version":3,"sources":["../src/Xrp.js"],"names":["Xrp","transport","scrambleKey","decorateAppAPIMethods","path","display","chainCode","ed25519","bipPath","fromString","toPathArray","curveMask","cla","ins","p1","p2","data","Buffer","alloc","length","writeInt8","forEach","segment","index","writeUInt32BE","send","response","result","publicKeyLength","addressLength","publicKey","slice","toString","address","rawTxHex","rawTx","apdus","offset","maxChunkSize","chunkSize","apdu","copy","push","version"],"mappings":";;;;;;;;AAGA;;;;;;;;;;AAEA;;;;;;;IAOqBA,G;AAGnB,eAAYC,SAAZ,EAAkE;AAAA,QAA7BC,WAA6B,uEAAP,KAAO;;AAAA;;AAChE,SAAKD,SAAL,GAAiBA,SAAjB;AACAA,cAAUE,qBAAV,CACE,IADF,EAEE,CAAC,YAAD,EAAe,iBAAf,EAAkC,qBAAlC,CAFF,EAGED,WAHF;AAKD;;AAED;;;;;;;;;;;;;;;;;0FAaEE,I,EACAC,O,EACAC,S,EACAC,O;;;;;;AAMMC,uB,GAAU,oBAAQC,UAAR,CAAmBL,IAAnB,EAAyBM,WAAzB,E;AACVC,yB,GAAYJ,UAAU,IAAV,GAAiB,I;AAE7BK,mB,GAAM,I;AACNC,mB,GAAM,I;AACNC,kB,GAAKT,UAAU,IAAV,GAAiB,I;AACtBU,kB,GAAKJ,aAAaL,YAAY,IAAZ,GAAmB,IAAhC,C;AACLU,oB,GAAOC,OAAOC,KAAP,CAAa,IAAIV,QAAQW,MAAR,GAAiB,CAAlC,C;;;AAEbH,qBAAKI,SAAL,CAAeZ,QAAQW,MAAvB,EAA+B,CAA/B;AACAX,wBAAQa,OAAR,CAAgB,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAClCP,uBAAKQ,aAAL,CAAmBF,OAAnB,EAA4B,IAAIC,QAAQ,CAAxC;AACD,iBAFD;;;uBAIuB,KAAKtB,SAAL,CAAewB,IAAf,CAAoBb,GAApB,EAAyBC,GAAzB,EAA8BC,EAA9B,EAAkCC,EAAlC,EAAsCC,IAAtC,C;;;AAAjBU,wB;AAEAC,sB,GAAS,E;AACTC,+B,GAAkBF,SAAS,CAAT,C;AAClBG,6B,GAAgBH,SAAS,IAAIE,eAAb,C;;;AAEtBD,uBAAOG,SAAP,GAAmBJ,SAASK,KAAT,CAAe,CAAf,EAAkB,IAAIH,eAAtB,EAAuCI,QAAvC,CAAgD,KAAhD,CAAnB;;AAEAL,uBAAOM,OAAP,GAAiBP,SACdK,KADc,CACR,IAAIH,eAAJ,GAAsB,CADd,EACiB,IAAIA,eAAJ,GAAsB,CAAtB,GAA0BC,aAD3C,EAEdG,QAFc,CAEL,OAFK,CAAjB;;AAIA,oBAAI1B,SAAJ,EAAe;AACbqB,yBAAOrB,SAAP,GAAmBoB,SAChBK,KADgB,CAEf,IAAIH,eAAJ,GAAsB,CAAtB,GAA0BC,aAFX,EAGf,IAAID,eAAJ,GAAsB,CAAtB,GAA0BC,aAA1B,GAA0C,EAH3B,EAKhBG,QALgB,CAKP,KALO,CAAnB;AAMD;;iDAEML,M;;;;;;;;;;;;;;;;;AAGT;;;;;;;;;;;;;;4FAWEvB,I,EACA8B,Q,EACA3B,O;;;;;;;AAEMC,uB,GAAU,oBAAQC,UAAR,CAAmBL,IAAnB,EAAyBM,WAAzB,E;AACVyB,qB,GAAQ,IAAIlB,MAAJ,CAAWiB,QAAX,EAAqB,KAArB,C;AACRvB,yB,GAAYJ,UAAU,IAAV,GAAiB,I;AAE7B6B,qB,GAAQ,E;AACVC,sB,GAAS,C;;;AAGX,sBAAMC,eAAeD,WAAW,CAAX,GAAe,MAAM,CAAN,GAAU7B,QAAQW,MAAR,GAAiB,CAA1C,GAA8C,GAAnE;AACA,sBAAMoB,YACJF,SAASC,YAAT,GAAwBH,MAAMhB,MAA9B,GACIgB,MAAMhB,MAAN,GAAekB,MADnB,GAEIC,YAHN;;AAKA,sBAAME,OAAO;AACX5B,yBAAK,IADM;AAEXC,yBAAK,IAFM;AAGXC,wBAAIuB,WAAW,CAAX,GAAe,IAAf,GAAsB,IAHf;AAIXtB,wBAAIJ,SAJO;AAKXK,0BACEqB,WAAW,CAAX,GACIpB,OAAOC,KAAP,CAAa,IAAIV,QAAQW,MAAR,GAAiB,CAArB,GAAyBoB,SAAtC,CADJ,GAEItB,OAAOC,KAAP,CAAaqB,SAAb;AARK,mBAAb;;AAWA,sBAAIF,WAAW,CAAf,EAAkB;AAChBG,yBAAKxB,IAAL,CAAUI,SAAV,CAAoBZ,QAAQW,MAA5B,EAAoC,CAApC;AACAX,4BAAQa,OAAR,CAAgB,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAClCiB,2BAAKxB,IAAL,CAAUQ,aAAV,CAAwBF,OAAxB,EAAiC,IAAIC,QAAQ,CAA7C;AACD,qBAFD;AAGAY,0BAAMM,IAAN,CACED,KAAKxB,IADP,EAEE,IAAIR,QAAQW,MAAR,GAAiB,CAFvB,EAGEkB,MAHF,EAIEA,SAASE,SAJX;AAMD,mBAXD,MAWO;AACLJ,0BAAMM,IAAN,CAAWD,KAAKxB,IAAhB,EAAsB,CAAtB,EAAyBqB,MAAzB,EAAiCA,SAASE,SAA1C;AACD;;AAEDH,wBAAMM,IAAN,CAAWF,IAAX;AACAH,4BAAUE,SAAV;;;AAlCF,uBAAOF,WAAWF,MAAMhB,MAAxB,EAAgC;AAAA;AAmC/B;;AAEGO,wB,GAAWT,OAAOC,KAAP,CAAa,CAAb,C;;;;;4BACEkB,K;;;;;;;;AAARI,qB;;uBACU,KAAKvC,SAAL,CAAewB,IAAf,CACfe,MAAK5B,GADU,EAEf4B,MAAK3B,GAFU,EAGf2B,MAAK1B,EAHU,EAIf0B,MAAKzB,EAJU,EAKfyB,MAAKxB,IALU,C;;;AAAjBU,wB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAUKA,SAASK,KAAT,CAAe,CAAf,EAAkBL,SAASP,MAAT,GAAkB,CAApC,EAAuCa,QAAvC,CAAgD,KAAhD,C;;;;;;;;;;;;;;;;;AAGT;;;;;;;;;;;;;;;;;;;;;;uBAcyB,KAAK/B,SAAL,CAAewB,IAAf,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,C;;;AAAjBC,wB;AACAC,sB,GAAS,E;;AACfA,uBAAOgB,OAAP,GAAiB,KAAKjB,SAAS,CAAT,CAAL,GAAmB,GAAnB,GAAyBA,SAAS,CAAT,CAAzB,GAAuC,GAAvC,GAA6CA,SAAS,CAAT,CAA9D;kDACOC,M;;;;;;;;;;;;;;;;;;;;;kBAnKU3B,G","file":"Xrp.js","sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BIPPath from \"bip32-path\";\n\n/**\n * Ripple API\n *\n * @example\n * import Xrp from \"@ledgerhq/hw-app-xrp\";\n * const xrp = new Xrp(transport);\n */\nexport default class Xrp {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"XRP\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\"getAddress\", \"signTransaction\", \"getAppConfiguration\"],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ripple address for a given BIP 32 path.\n   *\n   * @param path a path in BIP 32 format\n   * @param display optionally enable or not the display\n   * @param chainCode optionally enable or not the chainCode request\n   * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * const result = await xrp.getAddress(\"44'/144'/0'/0/0\");\n   * const { publicKey, address } = result;\n   */\n  async getAddress(\n    path: string,\n    display?: boolean,\n    chainCode?: boolean,\n    ed25519?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    const curveMask = ed25519 ? 0x80 : 0x40;\n\n    const cla = 0xe0;\n    const ins = 0x02;\n    const p1 = display ? 0x01 : 0x00;\n    const p2 = curveMask | (chainCode ? 0x01 : 0x00);\n    const data = Buffer.alloc(1 + bipPath.length * 4);\n\n    data.writeInt8(bipPath.length, 0);\n    bipPath.forEach((segment, index) => {\n      data.writeUInt32BE(segment, 1 + index * 4);\n    });\n\n    const response = await this.transport.send(cla, ins, p1, p2, data);\n\n    const result = {};\n    const publicKeyLength = response[0];\n    const addressLength = response[1 + publicKeyLength];\n\n    result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n\n    result.address = response\n      .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n      .toString(\"ascii\");\n\n    if (chainCode) {\n      result.chainCode = response\n        .slice(\n          1 + publicKeyLength + 1 + addressLength,\n          1 + publicKeyLength + 1 + addressLength + 32\n        )\n        .toString(\"hex\");\n    }\n\n    return result;\n  }\n\n  /**\n   * sign a Ripple transaction with a given BIP 32 path\n   *\n   * @param path a path in BIP 32 format\n   * @param rawTxHex a raw transaction hex string\n   * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)\n   * @return a signature as hex string\n   * @example\n   * const signature = await xrp.signTransaction(\"44'/144'/0'/0/0\", \"12000022800000002400000002614000000001315D3468400000000000000C73210324E5F600B52BB3D9246D49C4AB1722BA7F32B7A3E4F9F2B8A1A28B9118CC36C48114F31B152151B6F42C1D61FE4139D34B424C8647D183142ECFC1831F6E979C6DA907E88B1CAD602DB59E2F\");\n   */\n  async signTransaction(\n    path: string,\n    rawTxHex: string,\n    ed25519?: boolean\n  ): Promise<string> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    const rawTx = new Buffer(rawTxHex, \"hex\");\n    const curveMask = ed25519 ? 0x80 : 0x40;\n\n    const apdus = [];\n    let offset = 0;\n\n    while (offset !== rawTx.length) {\n      const maxChunkSize = offset === 0 ? 150 - 1 - bipPath.length * 4 : 150;\n      const chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n\n      const apdu = {\n        cla: 0xe0,\n        ins: 0x04,\n        p1: offset === 0 ? 0x00 : 0x80,\n        p2: curveMask,\n        data:\n          offset === 0\n            ? Buffer.alloc(1 + bipPath.length * 4 + chunkSize)\n            : Buffer.alloc(chunkSize)\n      };\n\n      if (offset === 0) {\n        apdu.data.writeInt8(bipPath.length, 0);\n        bipPath.forEach((segment, index) => {\n          apdu.data.writeUInt32BE(segment, 1 + index * 4);\n        });\n        rawTx.copy(\n          apdu.data,\n          1 + bipPath.length * 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        rawTx.copy(apdu.data, 0, offset, offset + chunkSize);\n      }\n\n      apdus.push(apdu);\n      offset += chunkSize;\n    }\n\n    let response = Buffer.alloc(0);\n    for (let apdu of apdus) {\n      response = await this.transport.send(\n        apdu.cla,\n        apdu.ins,\n        apdu.p1,\n        apdu.p2,\n        apdu.data\n      );\n    }\n\n    // the last 2 bytes are status code from the hardware\n    return response.slice(0, response.length - 2).toString(\"hex\");\n  }\n\n  /**\n   * get the version of the Ripple app installed on the hardware device\n   *\n   * @return an object with a version\n   * @example\n   * const result = await xrp.getAppConfiguration();\n   *\n   * {\n   *   \"version\": \"1.0.3\"\n   * }\n   */\n  async getAppConfiguration(): Promise<{\n    version: string\n  }> {\n    const response = await this.transport.send(0xe0, 0x06, 0x00, 0x00);\n    const result = {};\n    result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n    return result;\n  }\n}\n"]}